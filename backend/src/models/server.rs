use crate::models::{message::Message, node::Node};
use anyhow::Result;
use message_io::network::{Endpoint, NetEvent, Transport};
use message_io::node::{self, NodeEvent, NodeHandler, NodeListener};
use std::collections::HashMap;
use std::net::SocketAddr;

pub struct Server {
    handler: NodeHandler<()>,
    listeners: Option<NodeListener<()>>,
    nodes: Vec<Node>,
}

impl Server {
    pub fn new(port: u16) -> Result<Server> {
        let (handler, listeners) = node::split();
        let listen_addr = format!("127.0.0.1:{}", port);
        dbg!(&listen_addr);
        handler
            .network()
            .listen(Transport::FramedTcp, listen_addr)?;

        Ok(Self {
            handler,
            listeners: Some(listeners),
            nodes: Vec::new(),
        })
    }

    // Server listens
    pub fn run(&mut self) {
        let listener = self.listeners.take().unwrap();
        listener.for_each(move |event| match event {
            // interface from the network status
            NodeEvent::Network(net_event) => match net_event {
                NetEvent::Connected(endpoint, established) => self.handle_connected(endpoint, established),
                NetEvent::Accepted(endpoint, _) => self.handle_accepted(endpoint),
                NetEvent::Message(endpoint, bytes) => self.handle_message(endpoint, bytes),
                NetEvent::Disconnected(endpoint) => self.handle_disconnected(endpoint),
            },
            // interface self generated by the nodes - Accept incoming command
            NodeEvent::Signal(_signal) //=> match signal {
                // Signal::SendChunk => self.send_chunk(),
                => println!("Signal received, but not implemented!"),
            //},
        });
    }

    // Once the server connects to node? Maybe this will never get called?
    fn handle_connected(&mut self, endpoint: Endpoint, established: bool) {
        todo!("Figure out how this is invoked, and then update the implmentation below.");
        println!(
            "Something connected to the server! {}, {}",
            endpoint, established
        );
    }

    // Server accepts connection if through TCP, UDP will always accept connection no matter what
    fn handle_accepted(&mut self, endpoint: Endpoint) {
        println!("Server acccepts [{}]", endpoint.addr());
    }

    // Receive message from client nodes
    fn handle_message(&mut self, endpoint: Endpoint, bytes: &[u8]) {
        let msg: Message = bincode::deserialize(bytes).unwrap();

        match msg {
            // a new node register itself to the network!
            Message::RegisterNode { name, addr } => self.register_node(&name, addr, endpoint),
            Message::UnregisterNode { addr } => self.unregister_node(addr),
            // Client should not be sending us the jobs!
            //Message::LoadJob() => {}
            _ => todo!("Not yet implemented!"),
        }
    }

    fn handle_disconnected(&mut self, endpoint: Endpoint) {
        // I believe there's a reason why I cannot use endpoint.addr()
        // Instead, I need to match endpoint to endpoint from node struct instead
        match self.nodes.iter().position(|n| n.endpoint == endpoint) {
            Some(index) => {
                let unit = self.nodes.remove(index);
                let msg = Message::UnregisterNode { addr: unit.addr };
                self.send_to_all(msg);
                println!("Unregistered node '{}' with ip {}", unit.name, unit.addr);
            }
            None => {
                panic!("This should never happen! Unless I got the address wrong again?");
            }
        }
    }

    /// Notify all clients a node has been registered (Connected)
    fn register_node(&mut self, name: &str, addr: SocketAddr, endpoint: Endpoint) {
        let node = Node::new(name, addr, endpoint);
        self.send_to_all(Message::RegisterNode {
            name: node.name.clone(),
            addr: node.addr,
        });
        self.send_to_target(endpoint, self.create_node_list());
        self.nodes.push(node);
        println!("Node Registered successfully! '{}' [{}]", name, addr);
    }

    /// received notification from node being disconnected from the server.
    fn unregister_node(&mut self, addr: SocketAddr) {
        match self.nodes.iter().position(|n| n.addr == addr) {
            Some(index) => {
                let unit = self.nodes.remove(index);
                let msg = Message::UnregisterNode { addr: unit.addr };
                self.send_to_all(msg);
                println!("Unregistered node '{}' with ip {}", unit.name, unit.addr);
            }
            None => {
                println!("Foreign/Rogue node received! {}", addr);
            }
        }
    }

    fn create_node_list(&self) -> Message {
        let list = self
            .nodes
            .iter()
            .map(|n| (n.addr, n.name.clone()))
            .collect();
        Message::NodeList(list)
    }

    fn send_to_target(&self, endpoint: Endpoint, message: Message) {
        let data = bincode::serialize(&message).unwrap();
        self.handler.network().send(endpoint, &data);
    }

    /// Send message to all clients that's connected to the host.
    fn send_to_all(&self, message: Message) {
        println!("Sending {:?} to all clients", &message);
        let data = bincode::serialize(&message).unwrap();
        for node in &self.nodes {
            self.handler.network().send(node.endpoint, &data);
        }
    }
}
